#version 450

// Tile-Based Light Culling Compute Shader
// Assigns lights to 16x16 pixel tiles based on depth bounds and frustum intersection

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Depth buffer for building tile depth bounds
layout(set = 0, binding = 0) uniform sampler2D depthBuffer;

// Light data
struct Light {
    vec4 position;      // xyz = position, w = type (0=dir, 1=point, 2=spot)
    vec4 direction;     // xyz = direction, w = range
    vec4 color;         // xyz = color, w = intensity
    vec4 params;        // x = innerCone, y = outerCone, z = shadowMapIndex, w = unused
    mat4 lightSpaceMatrix;
};

#define MAX_LIGHTS 256
#define MAX_LIGHTS_PER_TILE 64

layout(set = 0, binding = 1) uniform LightBuffer {
    Light lights[MAX_LIGHTS];
    int numLights;
    float padding1;
    float padding2;
    float padding3;
} lightData;

// Camera/view data
layout(set = 0, binding = 2) uniform CameraBuffer {
    mat4 view;
    mat4 proj;
    mat4 invProj;
    vec4 viewPos;
    vec2 screenSize;
    float nearPlane;
    float farPlane;
} camera;

// Output: Light indices per tile
// Layout: [tileCount][MAX_LIGHTS_PER_TILE + 1]
// First element per tile is count, followed by light indices
layout(set = 0, binding = 3, std430) buffer LightIndexBuffer {
    uint lightIndices[];
};

// Shared memory for tile processing
shared uint tileMinDepthInt;
shared uint tileMaxDepthInt;
shared uint tileLightCount;
shared uint tileLightIndices[MAX_LIGHTS_PER_TILE];

// Tile frustum planes (shared for workgroup)
shared vec4 frustumPlanes[4];

// Convert depth from [0,1] to view-space Z
float linearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // Convert to NDC [-1, 1]
    return (2.0 * camera.nearPlane * camera.farPlane) /
           (camera.farPlane + camera.nearPlane - z * (camera.farPlane - camera.nearPlane));
}

// Create frustum plane from two points and origin
vec4 createPlane(vec3 p0, vec3 p1) {
    vec3 normal = normalize(cross(p1, p0));
    return vec4(normal, 0.0);
}

// Check if sphere intersects frustum
bool sphereInsideFrustum(vec3 center, float radius) {
    for (int i = 0; i < 4; ++i) {
        if (dot(frustumPlanes[i].xyz, center) + frustumPlanes[i].w < -radius) {
            return false;
        }
    }
    return true;
}

// Check if light affects tile
bool lightAffectsTile(Light light, float minZ, float maxZ) {
    int lightType = int(light.position.w);

    if (lightType == 0) {
        // Directional lights affect all tiles
        return true;
    }

    // Transform light to view space
    vec3 lightPos = (camera.view * vec4(light.position.xyz, 1.0)).xyz;
    float range = light.direction.w;

    // Check depth bounds
    if (lightPos.z - range > maxZ || lightPos.z + range < minZ) {
        return false;
    }

    // Check frustum planes
    return sphereInsideFrustum(lightPos, range);
}

void main() {
    uvec2 tileId = gl_WorkGroupID.xy;
    uint tileIndex = tileId.y * (uint(camera.screenSize.x) / 16) + tileId.x;
    uint localIndex = gl_LocalInvocationIndex;

    // Initialize shared memory
    if (localIndex == 0) {
        tileMinDepthInt = 0xFFFFFFFF;
        tileMaxDepthInt = 0;
        tileLightCount = 0;
    }
    barrier();

    // Calculate pixel position
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    if (pixelPos.x < int(camera.screenSize.x) && pixelPos.y < int(camera.screenSize.y)) {
        // Sample depth
        float depth = texelFetch(depthBuffer, pixelPos, 0).r;
        float linearDepth = linearizeDepth(depth);

        // Update tile depth bounds atomically
        uint depthInt = floatBitsToUint(linearDepth);
        atomicMin(tileMinDepthInt, depthInt);
        atomicMax(tileMaxDepthInt, depthInt);
    }
    barrier();

    // Build tile frustum planes (first thread only)
    if (localIndex == 0) {
        float minZ = uintBitsToFloat(tileMinDepthInt);
        float maxZ = uintBitsToFloat(tileMaxDepthInt);

        // Calculate tile corners in NDC
        vec2 tileMin = vec2(tileId) * 16.0 / camera.screenSize * 2.0 - 1.0;
        vec2 tileMax = vec2(tileId + 1) * 16.0 / camera.screenSize * 2.0 - 1.0;

        // Corner rays in view space (at z = -1)
        vec4 corners[4];
        corners[0] = camera.invProj * vec4(tileMin.x, tileMin.y, 1.0, 1.0);
        corners[1] = camera.invProj * vec4(tileMax.x, tileMin.y, 1.0, 1.0);
        corners[2] = camera.invProj * vec4(tileMax.x, tileMax.y, 1.0, 1.0);
        corners[3] = camera.invProj * vec4(tileMin.x, tileMax.y, 1.0, 1.0);

        for (int i = 0; i < 4; ++i) {
            corners[i] /= corners[i].w;
        }

        // Create frustum planes (pointing inward)
        frustumPlanes[0] = createPlane(corners[0].xyz, corners[1].xyz); // Bottom
        frustumPlanes[1] = createPlane(corners[1].xyz, corners[2].xyz); // Right
        frustumPlanes[2] = createPlane(corners[2].xyz, corners[3].xyz); // Top
        frustumPlanes[3] = createPlane(corners[3].xyz, corners[0].xyz); // Left
    }
    barrier();

    // Get tile depth bounds
    float tileMinZ = uintBitsToFloat(tileMinDepthInt);
    float tileMaxZ = uintBitsToFloat(tileMaxDepthInt);

    // Each thread culls a subset of lights
    uint lightsPerThread = (uint(lightData.numLights) + 255) / 256;
    uint lightStart = localIndex * lightsPerThread;
    uint lightEnd = min(lightStart + lightsPerThread, uint(lightData.numLights));

    for (uint i = lightStart; i < lightEnd; ++i) {
        Light light = lightData.lights[i];

        if (lightAffectsTile(light, tileMinZ, tileMaxZ)) {
            uint idx = atomicAdd(tileLightCount, 1);
            if (idx < MAX_LIGHTS_PER_TILE) {
                tileLightIndices[idx] = i;
            }
        }
    }
    barrier();

    // Write results to global buffer
    uint outputOffset = tileIndex * (MAX_LIGHTS_PER_TILE + 1);

    if (localIndex == 0) {
        lightIndices[outputOffset] = min(tileLightCount, MAX_LIGHTS_PER_TILE);
    }
    barrier();

    // Write light indices (distributed across threads)
    uint count = min(tileLightCount, MAX_LIGHTS_PER_TILE);
    for (uint i = localIndex; i < count; i += 256) {
        lightIndices[outputOffset + 1 + i] = tileLightIndices[i];
    }
}
