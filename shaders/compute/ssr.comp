#version 450

// Screen-Space Reflections using hierarchical ray marching
// Based on "Efficient GPU Screen-Space Ray Tracing" (McGuire & Mara, JCGT 2014)

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input textures
layout(set = 0, binding = 0) uniform sampler2D depthBuffer;
layout(set = 0, binding = 1) uniform sampler2D normalBuffer;
layout(set = 0, binding = 2) uniform sampler2D colorBuffer;
layout(set = 0, binding = 3) uniform sampler2D hizBuffer;

// Output
layout(set = 0, binding = 4, rgba16f) uniform writeonly image2D reflectionOutput;

// Push constants
layout(push_constant) uniform SSRParams {
    mat4 view;
    mat4 projection;
    mat4 invView;
    mat4 invProjection;
    vec4 screenSize;     // xy = size, zw = 1/size
    float maxDistance;
    float thickness;
    float roughnessFade;
    float edgeFade;
    uint maxSteps;
    uint binarySearchSteps;
    uint hizMipLevels;
    uint padding;
} params;

// Reconstruct view-space position from depth
vec3 reconstructViewPos(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 viewPos = params.invProjection * clipPos;
    return viewPos.xyz / viewPos.w;
}

// Convert view-space position to screen UV
vec3 projectToScreen(vec3 viewPos) {
    vec4 clipPos = params.projection * vec4(viewPos, 1.0);
    clipPos.xyz /= clipPos.w;
    return vec3(clipPos.xy * 0.5 + 0.5, clipPos.z);
}

// Decode normal from G-Buffer (octahedron encoding)
vec3 decodeNormal(vec2 encoded) {
    encoded = encoded * 2.0 - 1.0;
    vec3 n = vec3(encoded.xy, 1.0 - abs(encoded.x) - abs(encoded.y));
    float t = max(-n.z, 0.0);
    n.xy += vec2(n.x >= 0.0 ? -t : t, n.y >= 0.0 ? -t : t);
    return normalize(n);
}

// Get depth from Hi-Z buffer at specified mip level
float sampleHiZ(vec2 uv, int mipLevel) {
    return textureLod(hizBuffer, uv, float(mipLevel)).r;
}

// Hierarchical ray march
bool traceRay(vec3 rayOrigin, vec3 rayDir, out vec2 hitUV, out float hitDepth) {
    // Convert to screen space
    vec3 startScreen = projectToScreen(rayOrigin);
    vec3 endViewPos = rayOrigin + rayDir * params.maxDistance;
    vec3 endScreen = projectToScreen(endViewPos);

    // Ray in screen space
    vec3 rayScreen = endScreen - startScreen;

    // Early out if ray goes behind camera
    if (rayScreen.z < 0.0 && endScreen.z < 0.0) {
        return false;
    }

    // Normalize for stepping
    float rayLength = length(rayScreen.xy * params.screenSize.xy);
    if (rayLength < 1.0) return false;

    vec3 rayStep = rayScreen / rayLength;

    // Start position (offset slightly to avoid self-intersection)
    vec3 currentPos = startScreen + rayStep * 2.0;

    // Hierarchical tracing
    int mipLevel = int(params.hizMipLevels) - 1;
    float stepSize = 1.0;

    for (uint i = 0; i < params.maxSteps; ++i) {
        // Check bounds
        if (currentPos.x < 0.0 || currentPos.x > 1.0 ||
            currentPos.y < 0.0 || currentPos.y > 1.0 ||
            currentPos.z < 0.0 || currentPos.z > 1.0) {
            return false;
        }

        // Sample Hi-Z at current mip level
        float sceneDepth = sampleHiZ(currentPos.xy, mipLevel);

        // Check for intersection
        if (currentPos.z > sceneDepth) {
            // Potential hit - refine at lower mip level
            if (mipLevel > 0) {
                mipLevel--;
                stepSize *= 0.5;
                currentPos -= rayStep * stepSize;  // Step back
                continue;
            }

            // At finest level - check thickness
            float depthDiff = currentPos.z - sceneDepth;
            if (depthDiff < params.thickness) {
                // Binary search refinement
                vec3 lo = currentPos - rayStep * stepSize;
                vec3 hi = currentPos;

                for (uint j = 0; j < params.binarySearchSteps; ++j) {
                    vec3 mid = (lo + hi) * 0.5;
                    float midDepth = texture(depthBuffer, mid.xy).r;

                    if (mid.z > midDepth) {
                        hi = mid;
                    } else {
                        lo = mid;
                    }
                }

                hitUV = hi.xy;
                hitDepth = hi.z;
                return true;
            }
        } else {
            // No intersection - can step further at higher mip
            if (mipLevel < int(params.hizMipLevels) - 1) {
                mipLevel++;
                stepSize *= 2.0;
            }
        }

        // Advance ray
        currentPos += rayStep * stepSize;
    }

    return false;
}

// Calculate fade factor for screen edges
float calculateEdgeFade(vec2 uv) {
    vec2 edgeDist = min(uv, 1.0 - uv);
    float fade = min(edgeDist.x, edgeDist.y) / params.edgeFade;
    return clamp(fade, 0.0, 1.0);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 screenSize = params.screenSize.xy;

    if (pixelCoord.x >= int(screenSize.x) || pixelCoord.y >= int(screenSize.y)) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) * params.screenSize.zw;

    // Sample G-Buffer
    float depth = texture(depthBuffer, uv).r;

    // Skip sky pixels
    if (depth >= 1.0) {
        imageStore(reflectionOutput, pixelCoord, vec4(0.0));
        return;
    }

    // Get normal and roughness
    vec4 normalRoughness = texture(normalBuffer, uv);
    vec3 normal = decodeNormal(normalRoughness.xy);
    float roughness = normalRoughness.w;

    // Skip rough surfaces (no sharp reflections)
    if (roughness > params.roughnessFade) {
        imageStore(reflectionOutput, pixelCoord, vec4(0.0));
        return;
    }

    // Reconstruct view-space position
    vec3 viewPos = reconstructViewPos(uv, depth);

    // Transform normal to view space
    vec3 viewNormal = mat3(params.view) * normal;

    // Calculate reflection direction
    vec3 viewDir = normalize(viewPos);
    vec3 reflectDir = reflect(viewDir, viewNormal);

    // Skip reflections pointing away from camera
    if (reflectDir.z > 0.0) {
        imageStore(reflectionOutput, pixelCoord, vec4(0.0));
        return;
    }

    // Trace ray
    vec2 hitUV;
    float hitDepth;

    if (traceRay(viewPos, reflectDir, hitUV, hitDepth)) {
        // Sample scene color at hit point
        vec3 reflectedColor = texture(colorBuffer, hitUV).rgb;

        // Calculate confidence/fade factors
        float edgeFade = calculateEdgeFade(hitUV);
        float roughnessFade = 1.0 - (roughness / params.roughnessFade);
        float confidence = edgeFade * roughnessFade;

        imageStore(reflectionOutput, pixelCoord, vec4(reflectedColor, confidence));
    } else {
        imageStore(reflectionOutput, pixelCoord, vec4(0.0));
    }
}
