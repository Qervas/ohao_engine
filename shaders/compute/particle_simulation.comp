#version 450

// Particle system compute shader example
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Particle structure
struct Particle {
    vec3 position;
    float life;
    vec3 velocity;
    float mass;
    vec4 color;
};

// Storage buffers
layout(set = 0, binding = 0, std430) restrict buffer ParticleBuffer {
    Particle particles[];
};

layout(set = 0, binding = 1, std430) restrict readonly buffer ForceBuffer {
    vec3 forces[];
};

// Uniform buffer for simulation parameters
layout(set = 0, binding = 2) uniform SimulationParams {
    float deltaTime;
    float gravity;
    vec3 windForce;
    float damping;
    uint particleCount;
    float groundLevel;
    vec2 bounds; // x, z bounds
} params;

// Push constants for per-frame data
layout(push_constant) uniform PushConstants {
    mat4 viewMatrix;
    vec3 cameraPos;
    float time;
} pc;

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (index >= params.particleCount) {
        return;
    }
    
    Particle particle = particles[index];
    
    // Skip dead particles
    if (particle.life <= 0.0) {
        return;
    }
    
    // Apply forces
    vec3 totalForce = vec3(0.0, -params.gravity * particle.mass, 0.0);
    totalForce += params.windForce;
    
    // Add external forces if available
    if (index < forces.length()) {
        totalForce += forces[index];
    }
    
    // Update velocity (F = ma, so a = F/m)
    vec3 acceleration = totalForce / particle.mass;
    particle.velocity += acceleration * params.deltaTime;
    
    // Apply damping
    particle.velocity *= params.damping;
    
    // Update position
    particle.position += particle.velocity * params.deltaTime;
    
    // Collision with ground
    if (particle.position.y <= params.groundLevel) {
        particle.position.y = params.groundLevel;
        particle.velocity.y = -particle.velocity.y * 0.5; // Bounce with energy loss
    }
    
    // Collision with bounds
    if (abs(particle.position.x) > params.bounds.x) {
        particle.position.x = sign(particle.position.x) * params.bounds.x;
        particle.velocity.x = -particle.velocity.x * 0.8;
    }
    
    if (abs(particle.position.z) > params.bounds.y) {
        particle.position.z = sign(particle.position.z) * params.bounds.y;
        particle.velocity.z = -particle.velocity.z * 0.8;
    }
    
    // Update life
    particle.life -= params.deltaTime;
    
    // Fade color based on life
    float lifeFactor = max(particle.life / 2.0, 0.0); // Assuming max life of 2.0
    particle.color.a = lifeFactor;
    
    // Write back to buffer
    particles[index] = particle;
}